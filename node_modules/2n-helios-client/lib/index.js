var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Helios_baseURL, _Helios_httpsAgent, _Helios_auth, _Helios_ax;
// imports
import axios from 'axios';
import * as https from 'https';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import { logSub, logPull, fingerEnroll, fingerResult, fingerSub, fingerUnsub, userAccess, userDetails } from './helpers.js';
// import configs
dayjs.extend(utc);
class Helios {
    constructor(params) {
        _Helios_baseURL.set(this, void 0);
        _Helios_httpsAgent.set(this, void 0);
        _Helios_auth.set(this, void 0);
        _Helios_ax.set(this, void 0);
        /** Gets a log of successful entries within the specified days. */
        this.log = (days = 7) => __awaiter(this, void 0, void 0, function* () {
            const { subSuccess, id } = yield logSub(days, __classPrivateFieldGet(this, _Helios_ax, "f"));
            if (subSuccess) {
                const { pullSuccess, result } = yield logPull(id, __classPrivateFieldGet(this, _Helios_ax, "f"));
                if (pullSuccess) {
                    return result.events.map((e) => {
                        return { name: e.params.name, date: dayjs.unix(e.utcTime).format('YYYY-MM-DD HH:mm') };
                    });
                }
            }
        });
        /** Gets the status of the specified entry switch. */
        this.status = (sw = 1) => __awaiter(this, void 0, void 0, function* () {
            const { data } = yield __classPrivateFieldGet(this, _Helios_ax, "f").call(this, {
                url: `/switch/status`,
                method: 'get',
                params: {
                    switch: sw
                }
            });
            if (data.success) {
                const target = data.result.switches[0];
                if (target.active && !target.held) {
                    return 'Temporarily Opened';
                }
                else if (target.active && target.held) {
                    return 'Unlocked';
                }
                else if (!target.active) {
                    return 'Locked';
                }
            }
        });
        /** Opens, locks or unlocks the specified entry switch. */
        this.switch = (action, sw = 1) => __awaiter(this, void 0, void 0, function* () {
            let act = '';
            let msg = '';
            switch (action) {
                case 'lock':
                    act = 'release';
                    msg = 'locked';
                    break;
                case 'unlock':
                    act = 'hold';
                    msg = 'unlocked';
                    break;
                case 'open':
                    act = 'trigger';
                    msg = 'opened';
            }
            ;
            const { data } = yield __classPrivateFieldGet(this, _Helios_ax, "f").call(this, {
                url: `/switch/ctrl`,
                method: 'get',
                params: {
                    switch: sw,
                    action: act
                }
            });
            if (data.success) {
                console.log(`Switch ${sw} ${msg}.`);
                return true;
            }
        });
        /** Gets all users. */
        this.getUsers = () => __awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            formData.append('blob-json', JSON.stringify({ fields: ['name', 'access.pin'] }));
            const { data } = yield __classPrivateFieldGet(this, _Helios_ax, "f").call(this, {
                method: 'post',
                url: '/dir/query',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            if (data.success) {
                return data.result.users;
            }
            ;
        });
        /** Gets a specified user based on it's uuid. */
        this.getUser = (id) => __awaiter(this, void 0, void 0, function* () {
            const details = yield userDetails(id, __classPrivateFieldGet(this, _Helios_ax, "f"));
            return details;
        });
        this.removeUser = (id) => __awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            formData.append('blob-dir_new', JSON.stringify({ users: [{ uuid: id }] }));
            const { data } = yield __classPrivateFieldGet(this, _Helios_ax, "f").call(this, {
                method: 'put',
                url: '/dir/delete',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            if (data.success) {
                console.log('User deleted.');
                return true;
            }
            ;
        });
        /** Updates a specified user's access pin or fingerprint. */
        this.updateUserAccess = (id, params) => __awaiter(this, void 0, void 0, function* () {
            const didUpdate = yield userAccess(id, params, __classPrivateFieldGet(this, _Helios_ax, "f"));
            if (didUpdate) {
                console.log('User access updated.');
                return true;
            }
        });
        /** Adds a new user. */
        this.addUser = (name, email, params, uuid) => __awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            formData.append('blob-dir_new', JSON.stringify({ users: [{ uuid, name, email, access: params }] }));
            const { data } = yield __classPrivateFieldGet(this, _Helios_ax, "f").call(this, {
                method: 'put',
                url: '/dir/create',
                data: formData,
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            });
            if (data.success) {
                return { success: true, id: data.result.users[0].uuid };
            }
            ;
        });
        /** Remove a stored fingerprint for a user. */
        this.removeBio = (id, finger) => __awaiter(this, void 0, void 0, function* () {
            const details = yield userDetails(id, __classPrivateFieldGet(this, _Helios_ax, "f"));
            if (details.access.fpt) {
                const print = details.access.fpt;
                const prints = print.split(';');
                const found = prints.findIndex((e) => e.includes("#fid=" + finger));
                if (found != -1) {
                    prints.splice(found, 1);
                    const didUpdate = yield userAccess(id, { fpt: prints.toString() }, __classPrivateFieldGet(this, _Helios_ax, "f"));
                    console.log(didUpdate ? 'Fingerprint removed' : 'Error removing fingerprint');
                    return didUpdate;
                }
                else {
                    console.log('Fingerprint not found.');
                    return false;
                }
            }
            else {
                console.log('No fingerprint to remove.');
                return false;
            }
        });
        /** Starts fingerprint enrollment and updates the specified user if successful. */
        this.enrollBio = (id, finger = 6, reader = 2, callback) => __awaiter(this, void 0, void 0, function* () {
            let progress = 0;
            const { session } = yield fingerEnroll(reader, __classPrivateFieldGet(this, _Helios_ax, "f"));
            if (session) {
                const subId = yield fingerSub(__classPrivateFieldGet(this, _Helios_ax, "f"));
                const intervalID = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    const { success, result } = yield fingerResult(session, __classPrivateFieldGet(this, _Helios_ax, "f"));
                    if (!success) {
                        if (result === 12) {
                            clearInterval(intervalID);
                            console.log('Finger enrollment failed.');
                            callback(5);
                            return false;
                        }
                        else {
                            const { result } = yield logPull(subId, __classPrivateFieldGet(this, _Helios_ax, "f"));
                            if (result.events[0]) {
                                if (result.events[0].params.state === 'fingerScanned') {
                                    progress = progress + 1;
                                    callback(progress);
                                }
                            }
                        }
                    }
                    else if (success) {
                        fingerUnsub(subId, __classPrivateFieldGet(this, _Helios_ax, "f"));
                        clearInterval(intervalID);
                        let fingerprint = result + '#fid=' + finger + ',fn=1';
                        const details = yield userDetails(id, __classPrivateFieldGet(this, _Helios_ax, "f"));
                        if (details.access.fpt) {
                            fingerprint = fingerprint + ';' + details.access.fpt;
                        }
                        const fingerUpdated = yield userAccess(id, { fpt: fingerprint }, __classPrivateFieldGet(this, _Helios_ax, "f"));
                        if (fingerUpdated) {
                            console.log('Finger enrollment success.');
                            callback(4);
                        }
                        else {
                            console.log('Failed registering print.');
                            callback(5);
                        }
                    }
                }), 3000);
            }
        });
        this.ip = params.ip || '127.0.0.1',
            this.user = params.user || 'admin',
            this.pass = params.pass || 'admin',
            __classPrivateFieldSet(this, _Helios_baseURL, `https://${this.ip}/api`, "f"),
            __classPrivateFieldSet(this, _Helios_httpsAgent, new https.Agent({ rejectUnauthorized: false }), "f"),
            __classPrivateFieldSet(this, _Helios_auth, { username: this.user, password: this.pass }, "f"),
            __classPrivateFieldSet(this, _Helios_ax, axios.create({ auth: __classPrivateFieldGet(this, _Helios_auth, "f"), httpsAgent: __classPrivateFieldGet(this, _Helios_httpsAgent, "f"), baseURL: __classPrivateFieldGet(this, _Helios_baseURL, "f") }), "f");
    }
}
_Helios_baseURL = new WeakMap(), _Helios_httpsAgent = new WeakMap(), _Helios_auth = new WeakMap(), _Helios_ax = new WeakMap();
export default Helios;
